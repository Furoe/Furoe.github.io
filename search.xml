<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些杂念</title>
      <link href="2020/11/27/%E4%B8%80%E4%BA%9B%E6%9D%82%E5%BF%B5/"/>
      <url>2020/11/27/%E4%B8%80%E4%BA%9B%E6%9D%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>最近宿舍四人聚了一下，老二工资已经涨到30k了，然后想到自己进入了另一个坑，有点裂开，还好一开始就做好了进坑的准备。<br>学习一阵继续蹦跶吧，单身的人只想赚钱，感觉现在好缺钱，尤其是想买自己不需要的东西或者看房子没钱的时候，感觉极为强烈。<br>之前欢大佬毕业两年一直15级很惨，实际上发现人家收入不靠工资，人家是15-20薪，加几天班都能赚10k，哭了。<br>以后还是要进互联网大厂，年轻的时候多赚钱，程序员我觉得40岁差不多了，除非真正的大佬，否则应该退隐江湖了。<br>回到家，爷爷一大早就过来看我。<br>老人家确实是老了，不知不觉已经78了。<br>也只有休息的时候去跟老人家聊聊天，这次回家就是因为之前跟爷爷奶奶打电话，爷爷说想我了，于是就回家了。<br>回家第二天就下雪了，被封印在床上。<br>回到家才有所谓的安全感，每天睡得醒不过来。<br>生活是什么样子的，至少不是我喜欢的样子。<br>但我希望我能改变我现在的生活，过上我想要的生活。<br>快24了，加油吧，不大不小的年纪。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="2020/11/24/Vue/"/>
      <url>2020/11/24/Vue/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if-和v-show的区别"><a href="#v-if-和v-show的区别" class="headerlink" title="v-if 和v-show的区别"></a>v-if 和v-show的区别</h3><p><code>v-if</code>控制节点的存在，<code>v-show</code>控制节点的<code>display</code>属性。因此<code>v-if</code>的切换成本高，<code>v-show</code>的初始渲染成本高。所以<code>v-if</code>适用于条件几乎不变的情况，而切换比较频繁的时候适合使用<code>v-show</code>。<br><code>v-show</code>不支持<code>&lt;template&gt;</code>元素。</p><h3 id="template-functional"><a href="#template-functional" class="headerlink" title="template functional"></a>template functional</h3><p><code>functional</code>是函数式组件的一个标记，如果一个组件没有管理任何状态，也没有监听任何传给它的状态，没有声明周期方法。只是接收一些<code>props</code>的函数，在这种情况下可以将组件标记为<code>functional</code>，这表示它是无状态的(没有响应数据)，也没有实例(this上下文)。函数式组件本质上是函数，渲染开销小。</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是基于响应式依赖进行缓存的，只在相关依赖发生变化时进行重新计算，也就是说相关依赖没有发生变化的话会立即返回值。<br>计算属性默认只有<code>getter</code>，可以在需要时添加<code>setter</code>。  </p><h3 id="Class绑定"><a href="#Class绑定" class="headerlink" title="Class绑定"></a>Class绑定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;static&quot; :class&#x3D;&quot;&#123;active: isActive, &#39;text-danger&#39;: hasError&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>Vue将被侦听的数组变更方法进行了包裹，这些方法会触发视图变化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.stop</span><br><span class="line">.prevent</span><br><span class="line">.capture</span><br><span class="line">.self</span><br><span class="line">.once</span><br><span class="line">.passive</span><br><span class="line"></span><br><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用使用事件捕捉模式 --&gt;</span><br><span class="line">&lt;!-- 即内部事件在在这处理，然后才交给内部处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有event.target是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;a v-on:click.self&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>默认情况下，<code>v-model</code>在每次<code>input</code>事件触发后将输入框的值与数据进行同步，添加<code>lazy</code>修饰符后，只会在触发<code>change</code>事件时会同步。  </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind.lazy</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>自动将输入内容转换成数值类型。</p><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>自动过滤首尾空白字符。</p><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><h4 id="传入一个对象的所有property"><a href="#传入一个对象的所有property" class="headerlink" title="传入一个对象的所有property"></a>传入一个对象的所有<code>property</code></h4><p>如果想要将一个对象的所有<code>property</code>都作为<code>prop</code>传入，可以使用不带参数的<code>v-bind</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;blog-post v-bind=<span class="string">&quot;obj&quot;</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><h4 id="禁用Attribute继承"><a href="#禁用Attribute继承" class="headerlink" title="禁用Attribute继承"></a>禁用Attribute继承</h4><p>如果你不希望组件的根组件继承<code>attribute</code>，你可以在组件的选项中设置<code>inheritAttrs: false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h4><h4 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h4><p><code>prop</code>的双向绑定，可以使用<code>.sync</code>修饰符来使双向绑定更加简洁，但是不能搭配表达式使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text-document </span><br><span class="line">    v-bind:title&#x3D;&quot;doc.title&quot; </span><br><span class="line">    v-on:update:title&#x3D;&quot;doc.title&#x3D;$event&quot;&gt;</span><br><span class="line">&lt;&#x2F;text-document&gt;</span><br><span class="line"></span><br><span class="line">&lt;text-document v-bind:title.sync&#x3D;&quot;doc.title&quot;&gt;</span><br><span class="line">&lt;&#x2F;text-document&gt;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>vue 2.6 v-slot</p><h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>有时为一个插槽设置默认的内容很有必要，它只会在没有提供的时候被渲染。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;</span><br><span class="line">    &lt;slot&gt;submit&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;submit-button&gt;&lt;<span class="regexp">/submit-button&gt; /</span><span class="regexp">/渲染submit</span></span><br><span class="line"><span class="regexp">&lt;submit-button&gt;save&lt;/</span>submit-button&gt;  <span class="comment">//渲染save</span></span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="2020/11/19/Vuex/"/>
      <url>2020/11/19/Vuex/</url>
      
        <content type="html"><![CDATA[<p>vuex的核心就是仓库（store），包含着应用中大部分的状态(state)。<br>但是vuex和全局对象不同的是：<br>1、<code>vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从<code>store</code>中读取状态时，如果发生变化，那么相应的组件也会得到高效的更新。<br>2、不能直接修改<code>store</code>中的状态。<code>vuex</code>的状态修改只能通过显示提交(commit)<code>mutation</code>修改。  </p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>由于<code>vuex</code>中状态是响应式存储的，所以获取状态的简单方法是在计算属性中返回状态。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">count</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免取多个状态时的重复写法，可以使用mapState进行辅助</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        <span class="comment">//箭头函数简练</span></span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传字符参数等同上箭头函数</span></span><br><span class="line">        countAlias： <span class="string">&quot;count&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能使用this获取局部状态，必须使用常规函数</span></span><br><span class="line">        <span class="function"><span class="title">countPlusLocalState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p><code>vuex</code>允许在store中定义<code>getters</code>，就像计算属性一样，<code>getters</code>的返回值会根据它的依赖被缓存起来，且只有它的依赖值发生改变才会被重新计算。<br><code>getter</code>接受<code>state</code>作为第一个参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getter</code>接受<code>getter</code>作为第二个参数<br><code>getter</code>可以通过属性访问，这时候getter是作为Vue响应式系统的一部分缓存其中的。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    doneTodos: <span class="function">(<span class="params">state, getter</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodos</span><br></pre></td></tr></table></figure><p>也可以通过方法访问，每次都会去调用，不会进行缓存。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id == id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.getters.getTodoById(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>mapGetters辅助函数仅仅是将getters映射到部分计算属性  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapGetters([</span><br><span class="line">            <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;anotherGetter&#x27;</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>异步改变状态需要使用<code>action</code>，<code>action</code>不直接更改状态，而是发起<code>mutation</code></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>是改变<code>store</code>中状态的执行者，只能是同步操作。</p><h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><p>对于大型应用，可以将仓库分割成子模块。</p><h3 id="通过几个问题理解vuex的原理"><a href="#通过几个问题理解vuex的原理" class="headerlink" title="通过几个问题理解vuex的原理"></a>通过几个问题理解vuex的原理</h3><h4 id="vuex的store是如何注入到组件中的？"><a href="#vuex的store是如何注入到组件中的？" class="headerlink" title="vuex的store是如何注入到组件中的？"></a>vuex的store是如何注入到组件中的？</h4><p><code>Vue.use(Vuex)</code>会调用<code>install</code>方法，装载<code>vuex</code>。<br>然后看看<code>install</code>的执行逻辑。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate(): &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.$options &amp;&amp; <span class="built_in">this</span>.$options.store</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent.$store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>综上可知，vuex的注入是通过minxin的方法，在vue构建实例时通过钩子函数<code>beforeCreate</code>注入的。</p><h4 id="Getters的实现"><a href="#Getters的实现" class="headerlink" title="Getters的实现"></a>Getters的实现</h4><p><code>vuex</code>和<code>vue</code>一样是响应式的，<code>state</code>是通过放入<code>data</code>中实现，而<code>getters</code>是通过放入<code>computed</code>中做到响应式的。  </p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scss</title>
      <link href="2020/11/15/scss/"/>
      <url>2020/11/15/scss/</url>
      
        <content type="html"><![CDATA[<h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>sass根据语法分为两种格式Sass和Scss。<br>scss与css更类似，有大括号，文件后缀是.scss。<br>sass使用缩进来表示关系，文件后缀是.sass。  </p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>变量以$开头，用来存储重复使用的数据，包括宽度、高度和颜色等等。<br>如果变量需要嵌在字符串中，则需要写在<code>#&#123;&#125;</code>中。<br>但是如果变量是数字要避免<code>#&#123;$value&#125;px</code>这种写法，尽量使用<code>$value * 1px</code>。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$side</span>: left;</span><br><span class="line"><span class="selector-class">.rounded</span> &#123;</span><br><span class="line"><span class="attribute">border</span>-#&#123;<span class="variable">$side</span>&#125;-radius: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">###### 全局变量与局部变量</span><br><span class="line">定义在顶层的是全局变量，定义在块中的是局部变量，局部变量可以跟全局变量重名。  </span><br><span class="line">```SCSS</span><br><span class="line"><span class="variable">$global-variable</span>: global value;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line"><span class="variable">$local-variable</span>: local value;</span><br><span class="line">global: <span class="variable">$global-variable</span>;</span><br><span class="line">local: <span class="variable">$local-variable</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">如果需要在局部环境声明一个全局变量，使用!global标志。</span><br><span class="line">```SCSS</span><br><span class="line"><span class="variable">$variable</span>: first global value;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line"><span class="variable">$variable</span>: second global value !global;</span><br><span class="line">value: <span class="variable">$variable</span>;  <span class="comment">//second global value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">value: <span class="variable">$variable</span>;  <span class="comment">// second global value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line"><span class="selector-class">.ul</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//css</span><br><span class="line">nav ul&#123;</span><br><span class="line">margin: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套的代码块中，可以引用父级元素。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ffb3ff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>不需要将所有sass写在同一个文件中，可以根据功能或者意义分割成模块。<br>然后使用<code>@use</code>引入模块。当前只有Dart Sass支持<code>@use</code>，其他使用<code>@import</code>。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_base.scss</span></span><br><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//style.scss</span></span><br><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;base&#x27;</span>;</span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: base.<span class="variable">$primary-color</span>;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h5><p>在考虑浏览器兼容性的时候，有很多属性需要重复写，这时候使用混入，用混入<br>的方式写兼容性语句，只需要考虑样式的值，不需要重复的书写。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> transfrom(<span class="variable">$property</span>) &#123;</span><br><span class="line">-webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123; <span class="keyword">@include</span> tansform(rorate(<span class="number">30deg</span>)); &#125;</span><br></pre></td></tr></table></figure><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>当一个基本样式不变的组件有多种样式，使用继承的方式可以减少重复代码。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%message-shared &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%message-heights &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span>&#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sucess</span> &#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line"><span class="attribute">border</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line"><span class="attribute">border</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>sass支持一些标准的数学运算符，比如+、-、*、/和%。  </p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role=&#x27;main&#x27;]</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role=&#x27;complementary&#x27;]</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">##### 注释</span><br><span class="line">标准的注释<span class="comment">/* comment */</span>，会保留到编译后的文件。  </span><br><span class="line">单行注释<span class="comment">// comment，只保留在源文件中，编译后被省略。  </span></span><br><span class="line">在<span class="comment">/*后加上!，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常  </span></span><br><span class="line"><span class="comment">可以用于声明版权信息。  </span></span><br><span class="line"><span class="comment">```SCSS</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    important comment</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h5><h6 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h6><p><code>@if</code>和<code>@else</code></p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> === <span class="number">2</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid; &#125;</span><br><span class="line"><span class="keyword">@else</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> dotted; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> to <span class="number">10</span> &#123;</span><br><span class="line"><span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="variable">$i</span> * <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环</span></span><br><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line"><span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//each</span></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">.#&#123;member&#125; &#123;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">&#x27;/image/#&#123;member&#125;.jpg&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> double(<span class="variable">$n</span>) &#123;</span><br><span class="line"><span class="keyword">@return</span> <span class="variable">$n</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sider</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%)  <span class="comment">//#d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%)  <span class="comment">//#a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>)  <span class="comment">//#808080</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">//#33c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SCSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="2020/11/14/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2020/11/14/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>最近因为碰到取值问题打算好好看下Vue的生命周期，之前只是简单的了解了下Vue的生命周期。浅略的知道分为<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>、<code>beforeUpdate</code>、<code>updated</code>、<code>beforeDestroy</code>、<code>destroyed</code>，但是对于在这之间Vue的不同阶段到底做了什么不甚了解。</p><h5 id="vue的源码"><a href="#vue的源码" class="headerlink" title="vue的源码"></a>vue的源码</h5><p>分析生命周期，我们首先得从创建vue实例开始。<br>在<code>new Vue()</code>的时候，<code>vue/src/core/instance/index.js</code>中的<code>_init()</code>负责初始化各个功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> instance Vue)</span>)</span>&#123;</span><br><span class="line">        warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_init</code>中的执行顺序为下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initLifeClircle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">initInjections(vm)  <span class="comment">//resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm)  <span class="comment">//resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而在<code>initState()</code>中执行顺序如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(opts.props) initProps(vm, opts.props)  <span class="comment">//初始化props</span></span><br><span class="line"><span class="keyword">if</span>(opts.methods) initMethods(vm, opts.methods)  <span class="comment">//初始化methods</span></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">opts.data</span>)</span> &#123;</span><br><span class="line">    initData(vm, opts.data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* as root data*/</span>);  <span class="comment">//初始化data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opts.computed) initComputed(vm, opts.computed);  <span class="comment">//初始化computed</span></span><br></pre></td></tr></table></figure><p>可以看出先执行<code>props</code>，然后是<code>methods</code>，紧接着是<code>data</code>最后是<code>computed</code>。并且这个阶段是在<code>beforeCreated</code>和<code>created</code>之间，<br>所以使用computed中的数据时需要慎重。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> lifeCircle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="2020/11/14/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>2020/11/14/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="重新搭建的原因"><a href="#重新搭建的原因" class="headerlink" title="重新搭建的原因"></a>重新搭建的原因</h4><p>因为以前的博客由于种种事由断更了很久，电脑也换了一个又一个。<br>原来的项目源文件已经丢失了，只剩下现在的编译之后的静态页面，<br>虽然是打算自己搭网站的，但是最近一直没空，先维护一下静态博客。</p><h4 id="使用的脚手架"><a href="#使用的脚手架" class="headerlink" title="使用的脚手架"></a>使用的脚手架</h4><p>依然是<a href="https://hexo.io/">hexo</a>，不过主题这次选择melody，<a href="https://molunerfinn.com/hexo-theme-melody-doc/">melody相关配置</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> melody </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/14/hello-world/"/>
      <url>2020/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
