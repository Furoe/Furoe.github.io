<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue-router学习记录</title>
      <link href="2021/01/07/vue-router%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>2021/01/07/vue-router%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.push(location, onComplete?, onAbort?)</span><br></pre></td></tr></table></figure><p>|声明式|编程式|<br>|<code>&lt;router-link :to=&#39;...&#39;&gt;</code>|<code>router.push(...)</code>|<br>注意：如果目的路由与当前路由相同，只是参数发生变化，需要使用<code>beforeRouteUpdate</code>来响应这个变化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.replace(location, onComplete?, onAbort?)</span><br></pre></td></tr></table></figure><p>|声明式|编程式|<br>|<code>&lt;router-link :to=&#39;...&#39; replace&gt;</code>|<code>router.replace()</code>|<br><code>router.replace</code>与<code>router.push</code>很像，但是<code>router.replace</code>不会向<code>history</code>添加新纪录，而是替换掉当前<code>history</code>的记录。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.go(n)</span><br></pre></td></tr></table></figure><p>类似于<code>window.history.go(n)</code></p><h4 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pass</span></span><br><span class="line"><span class="comment">//后续补充，还没理解耦合问题</span></span><br></pre></td></tr></table></figure><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><p><code>router.beforeEach</code>注册全局前置守卫，当一个导航触发时，全局前置守卫是按照创建顺序调用。守卫是异步解析执行的，此时导航所在守卫的<code>resolve</code>都在等待中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;...&#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>to: router</code>：即将要进入的目标</li><li><code>from: route</code>：当前导航正要离开的路由</li><li><code>next: function</code>：resolve钩子  </li><li><code>next()</code>：进入管道中的下一个钩子，如果管道中钩子都执行完，导航的状态变为<code>confirmed</code>。</li><li><code>next(false)</code>：中断当前导航。如果浏览器URL变化了，那么URL地址会重置到<code>from</code>路由对应的地址。</li><li><code>next(error)(2.4.0+)</code>：导航会被终止且错误会被传递给<code>router.onError</code>的回调  </li></ul><p>任何给定的导航守卫中，<code>next</code>函数都需要被严格调用一次。他可以出现多于一次，但是只能在所有逻辑路径都不重叠的情况下，否则钩子永远都不解析或报错。</p><h5 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h5><blockquote><p>2.5.0+  </p></blockquote><p><code>router.beforeResolve</code>与<code>router.beforeEach</code>类似，在导航确认之前，所有组件内守卫和异步路由被解析后调用。</p><h5 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;to&#x27;</span>,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//pass</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h5><blockquote><p>beforRouteEnter<br>beforRouteUpdate (2.2+)<br>beforRouteLeave  </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 在渲染该组件的路由没有被确认前调用</span></span><br><span class="line">  <span class="comment">// 不能获取组件实例this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 在当前路由改变，但是当前路由被复用时调用</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">  <span class="comment">// 可以访问组件实例this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><p>1、触发导航<br>2、在失活的组件中调用<code>beforeRouteLeave</code><br>3、调用全局的<code>beforeEach</code><br>4、在重用的组件中调用<code>beforeRouteUpdate</code><br>5、在路由配置中调用<code>beforeEnter</code><br>6、解析异步路由<br>7、在被激活的组件中调用<code>beforeRouteEnter</code><br>8、调用全局的<code>beforeRouteResolve</code><br>9、导航被确认<br>10、调用全局<code>afterEach</code><br>11、触发DOM更新<br>12、调用<code>beforeRouteEnter</code>中传入<code>next</code>的回调函数，创建好的组件会作为回调函数的参数传入</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="2021/01/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>2021/01/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h4><p>当只是想纯粹的展示数据时，这时候可以通过禁止<code>Vue</code>劫持数据来减少组件初始化的时间。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        users: &#123;&#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">&#x27;/api/user&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.users = <span class="built_in">Object</span>.freeze(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h4><p><code>Vue</code>组件销毁时，会自动清理它与其它实例的关联，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果使用了<code>addEventListener</code>等方式是不会自动销毁的，需要手动清理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>进入首页时，如果加载的资源过多，会导致白屏，使用路由懒加载，只有路由被访问的时候才加载，能大大提升首页显示的速度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">            component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> performance-optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟DOM和增量DOM</title>
      <link href="2021/01/05/%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%A2%9E%E9%87%8FDOM/"/>
      <url>2021/01/05/%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%A2%9E%E9%87%8FDOM/</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><h4 id="虚拟DOM的工作流程"><a href="#虚拟DOM的工作流程" class="headerlink" title="虚拟DOM的工作流程"></a>虚拟DOM的工作流程</h4><ul><li>当用户UI发生变化时，将整个用户UI渲染到虚拟DOM中</li><li>将当前虚拟DOM与之前的虚拟DOM进行比较，计算表现形式间的差异</li><li>根据变化差异更新真实DOM<h4 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h4>优点</li><li>高效的diff算法</li><li>简单且有助于提升性能</li><li>轻量</li><li>允许构建应用程序不需要考虑状态转换<br>缺点</li><li>哪怕只是微小变化，也会检查所有步骤来识别变化  </li></ul><h3 id="增量DOM"><a href="#增量DOM" class="headerlink" title="增量DOM"></a>增量DOM</h3><h4 id="增量DOM的工作方式"><a href="#增量DOM的工作方式" class="headerlink" title="增量DOM的工作方式"></a>增量DOM的工作方式</h4><p>增量DOM通过使用真实DOM来定位代码更新，这种方法比虚拟DOM简单，内存中不会存任何真实DOM的虚拟表示来计算差异，真实DOM仅用于与新的DOM进行差异比较。  </p><h4 id="增量DOM的优缺点"><a href="#增量DOM的优缺点" class="headerlink" title="增量DOM的优缺点"></a>增量DOM的优缺点</h4><p>优点</p><ul><li>易于与其他框架结合使用</li><li>简单的API使其成为强大的目标模板引擎</li><li>适合基于移动设备的应用程序<br>缺点</li><li>耗时  </li></ul><h3 id="虚拟DOM和增量DOM的区别"><a href="#虚拟DOM和增量DOM的区别" class="headerlink" title="虚拟DOM和增量DOM的区别"></a>虚拟DOM和增量DOM的区别</h3><ul><li>虚拟DOM不直接操作真实DOM而是计算差异再更新，增量DOM直接操作真实DOM</li><li>虚拟DOM用的是解释器，无法使用tree shaking，而增量DOM可以</li><li>虚拟DOM在内存中存放真实DOM的虚拟表示，占用大量内存，增量DOM不会</li></ul>]]></content>
      
      
      <categories>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现瀑布流</title>
      <link href="2021/01/01/CSS%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81/"/>
      <url>2021/01/01/CSS%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>之前没有写过瀑布流，最近需要改一个东西，学习一下。<br>瀑布流的实现主要通过几个关键属性来实现。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;content&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>columns</code>代表瀑布流中流的数量，<code>column-gap</code>代表流之间的间距，<code>break-inside</code>用来避免流内的内容被隔开。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">columns</span>: <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">column-gap</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">break-inside</span>: avoid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-2021的总结</title>
      <link href="2020/12/31/2020-2021/"/>
      <url>2020/12/31/2020-2021/</url>
      
        <content type="html"><![CDATA[<p>在2020年12月31日的22：05分，看着B站跨年晚会的时候，写下这篇关于2020的回顾。<br>2020年是一个比较特殊的年度，对我来说，从开始到结尾都和往年不一样。<br>去年过年的时候因为抢不到票，太麻烦了就想着一个人体验下安静的生活。在我妈劝我回家的过程中，疫情就爆发了，我突然就变成了大人，日常让家人少出门，注意安全，变成了自己讨厌的唠叨模样。<br>年初的时候制定了关于2020的规划，于是一边摸鱼划水，一边学习。<br>坚持了一阵，又放弃了一阵，又捡起来一阵。<br>一直到了九月份才真正的开始认真的准备换工作的事情，于是先打了一个月的游戏，打到自己心态崩了。<br>然后裸辞开始啃知识，每天刷着leetcode，虽然痛苦，但是也很快乐。<br>找工作的时候其实挺挫败的，因为毕业两年都没有认真学习，自己的过去要自己承担。<br>最后机缘巧合的又回到了南京，在南京，幸福感有些提升。也许是熟悉，也许是终于有了目标。虽然不是每一天都在往制定的目标上冲，但是离目标越来越近。<br>因为觉得自己菜，所以现在被工作PUA也还能接受，大概一年左右又要换工作了。<br>现在更多是对家庭的考虑，之前和爷爷打电话，爷爷说想我了，还说到不知道自己还能活多少年，突然就觉得时间匆匆。<br>工作的事情安定了就立刻回家了，陪爷爷奶奶聊聊天挺好的。<br>今年也和朋友们见了见聊了聊，才发现认识的朋友也都好多年了，确实开始变老了。<br>每一年都要有一个规划，好让自己离人生目标越来越近。<br>五月的最后有五月天，2020的最后一天依然是五月天。<br>2020最爱的还是五月天，每次听着五月天的歌，都会有勇气继续努力下去。<br>2020看过了16本书，大部分是小说，但是看的最久的是《你不知道的JavaScript》。<br>2020也是经历过996的人了，即将进入本命年的年纪，要继续努力。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些杂念</title>
      <link href="2020/11/27/%E4%B8%80%E4%BA%9B%E6%9D%82%E5%BF%B5/"/>
      <url>2020/11/27/%E4%B8%80%E4%BA%9B%E6%9D%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>最近宿舍四人聚了一下，老二工资已经涨到30k了，然后想到自己进入了另一个坑，有点裂开，还好一开始就做好了进坑的准备。<br>学习一阵继续蹦跶吧，单身的人只想赚钱，感觉现在好缺钱，尤其是想买自己不需要的东西或者看房子没钱的时候，感觉极为强烈。<br>之前欢大佬毕业两年一直15级很惨，实际上发现人家收入不靠工资，人家是15-20薪，加几天班都能赚10k，哭了。<br>以后还是要进互联网大厂，年轻的时候多赚钱，程序员我觉得40岁差不多了，除非真正的大佬，否则应该退隐江湖了。<br>回到家，爷爷一大早就过来看我。<br>老人家确实是老了，不知不觉已经78了。<br>也只有休息的时候去跟老人家聊聊天，这次回家就是因为之前跟爷爷奶奶打电话，爷爷说想我了，于是就回家了。<br>回家第二天就下雪了，被封印在床上。<br>回到家才有所谓的安全感，每天睡得醒不过来。<br>生活是什么样子的，至少不是我喜欢的样子。<br>但我希望我能改变我现在的生活，过上我想要的生活。<br>快24了，加油吧，不大不小的年纪。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="2020/11/24/Vue/"/>
      <url>2020/11/24/Vue/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if-和v-show的区别"><a href="#v-if-和v-show的区别" class="headerlink" title="v-if 和v-show的区别"></a>v-if 和v-show的区别</h3><p><code>v-if</code>控制节点的存在，<code>v-show</code>控制节点的<code>display</code>属性。因此<code>v-if</code>的切换成本高，<code>v-show</code>的初始渲染成本高。所以<code>v-if</code>适用于条件几乎不变的情况，而切换比较频繁的时候适合使用<code>v-show</code>。<br><code>v-show</code>不支持<code>&lt;template&gt;</code>元素。</p><h3 id="template-functional"><a href="#template-functional" class="headerlink" title="template functional"></a>template functional</h3><p><code>functional</code>是函数式组件的一个标记，如果一个组件没有管理任何状态，也没有监听任何传给它的状态，没有声明周期方法。只是接收一些<code>props</code>的函数，在这种情况下可以将组件标记为<code>functional</code>，这表示它是无状态的(没有响应数据)，也没有实例(this上下文)。函数式组件本质上是函数，渲染开销小。</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是基于响应式依赖进行缓存的，只在相关依赖发生变化时进行重新计算，也就是说相关依赖没有发生变化的话会立即返回值。<br>计算属性默认只有<code>getter</code>，可以在需要时添加<code>setter</code>。  </p><h3 id="Class绑定"><a href="#Class绑定" class="headerlink" title="Class绑定"></a>Class绑定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;static&quot; :class&#x3D;&quot;&#123;active: isActive, &#39;text-danger&#39;: hasError&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>Vue将被侦听的数组变更方法进行了包裹，这些方法会触发视图变化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.stop</span><br><span class="line">.prevent</span><br><span class="line">.capture</span><br><span class="line">.self</span><br><span class="line">.once</span><br><span class="line">.passive</span><br><span class="line"></span><br><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用使用事件捕捉模式 --&gt;</span><br><span class="line">&lt;!-- 即内部事件在在这处理，然后才交给内部处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有event.target是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;a v-on:click.self&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>默认情况下，<code>v-model</code>在每次<code>input</code>事件触发后将输入框的值与数据进行同步，添加<code>lazy</code>修饰符后，只会在触发<code>change</code>事件时会同步。  </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind.lazy</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>自动将输入内容转换成数值类型。</p><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>自动过滤首尾空白字符。</p><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><h4 id="传入一个对象的所有property"><a href="#传入一个对象的所有property" class="headerlink" title="传入一个对象的所有property"></a>传入一个对象的所有<code>property</code></h4><p>如果想要将一个对象的所有<code>property</code>都作为<code>prop</code>传入，可以使用不带参数的<code>v-bind</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;blog-post v-bind=<span class="string">&quot;obj&quot;</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><h4 id="禁用Attribute继承"><a href="#禁用Attribute继承" class="headerlink" title="禁用Attribute继承"></a>禁用Attribute继承</h4><p>如果你不希望组件的根组件继承<code>attribute</code>，你可以在组件的选项中设置<code>inheritAttrs: false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h4><h4 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h4><p><code>prop</code>的双向绑定，可以使用<code>.sync</code>修饰符来使双向绑定更加简洁，但是不能搭配表达式使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text-document </span><br><span class="line">    v-bind:title&#x3D;&quot;doc.title&quot; </span><br><span class="line">    v-on:update:title&#x3D;&quot;doc.title&#x3D;$event&quot;&gt;</span><br><span class="line">&lt;&#x2F;text-document&gt;</span><br><span class="line"></span><br><span class="line">&lt;text-document v-bind:title.sync&#x3D;&quot;doc.title&quot;&gt;</span><br><span class="line">&lt;&#x2F;text-document&gt;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>vue 2.6 v-slot</p><h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>有时为一个插槽设置默认的内容很有必要，它只会在没有提供的时候被渲染。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;</span><br><span class="line">    &lt;slot&gt;submit&lt;/slot&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;submit-button&gt;&lt;<span class="regexp">/submit-button&gt; /</span><span class="regexp">/渲染submit</span></span><br><span class="line"><span class="regexp">&lt;submit-button&gt;save&lt;/</span>submit-button&gt;  <span class="comment">//渲染save</span></span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p><code>$refs</code>只会在组件渲染完时生效，并且他们不是响应式的。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p><code>provide</code>选项允许执行想要提供给后代组件的数据/方法。<br>负面效果就是造成了强耦合。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getMap: <span class="built_in">this</span>.getMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在后代中都可以通过inject获取</span></span><br><span class="line">inject: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h3><p>挂载第三方库的时候，需要</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.picker = <span class="keyword">new</span> Pickaday(&#123;</span><br><span class="line">        field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">        format: <span class="string">&#x27;YYYY-DD-MM&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroyed&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><h3 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h3><p><code>$forceUpdate</code>可以用来强制更新，但是<code>Vue</code>本身就是响应式，应该避免这些用法，多考虑是不是自己用错了。 </p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="2020/11/19/Vuex/"/>
      <url>2020/11/19/Vuex/</url>
      
        <content type="html"><![CDATA[<p>vuex的核心就是仓库（store），包含着应用中大部分的状态(state)。<br>但是vuex和全局对象不同的是：<br>1、<code>vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从<code>store</code>中读取状态时，如果发生变化，那么相应的组件也会得到高效的更新。<br>2、不能直接修改<code>store</code>中的状态。<code>vuex</code>的状态修改只能通过显示提交(commit)<code>mutation</code>修改。  </p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>由于<code>vuex</code>中状态是响应式存储的，所以获取状态的简单方法是在计算属性中返回状态。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">count</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免取多个状态时的重复写法，可以使用mapState进行辅助</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        <span class="comment">//箭头函数简练</span></span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传字符参数等同上箭头函数</span></span><br><span class="line">        countAlias： <span class="string">&quot;count&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了能使用this获取局部状态，必须使用常规函数</span></span><br><span class="line">        <span class="function"><span class="title">countPlusLocalState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p><code>vuex</code>允许在store中定义<code>getters</code>，就像计算属性一样，<code>getters</code>的返回值会根据它的依赖被缓存起来，且只有它的依赖值发生改变才会被重新计算。<br><code>getter</code>接受<code>state</code>作为第一个参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getter</code>接受<code>getter</code>作为第二个参数<br><code>getter</code>可以通过属性访问，这时候getter是作为Vue响应式系统的一部分缓存其中的。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    doneTodos: <span class="function">(<span class="params">state, getter</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodos</span><br></pre></td></tr></table></figure><p>也可以通过方法访问，每次都会去调用，不会进行缓存。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id == id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.getters.getTodoById(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>mapGetters辅助函数仅仅是将getters映射到部分计算属性  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        ...mapGetters([</span><br><span class="line">            <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;anotherGetter&#x27;</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>异步改变状态需要使用<code>action</code>，<code>action</code>不直接更改状态，而是发起<code>mutation</code></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>是改变<code>store</code>中状态的执行者，只能是同步操作。</p><h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><p>对于大型应用，可以将仓库分割成子模块。</p><h3 id="通过几个问题理解vuex的原理"><a href="#通过几个问题理解vuex的原理" class="headerlink" title="通过几个问题理解vuex的原理"></a>通过几个问题理解vuex的原理</h3><h4 id="vuex的store是如何注入到组件中的？"><a href="#vuex的store是如何注入到组件中的？" class="headerlink" title="vuex的store是如何注入到组件中的？"></a>vuex的store是如何注入到组件中的？</h4><p><code>Vue.use(Vuex)</code>会调用<code>install</code>方法，装载<code>vuex</code>。<br>然后看看<code>install</code>的执行逻辑。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate(): &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.$options &amp;&amp; <span class="built_in">this</span>.$options.store</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = <span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent.$store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>综上可知，vuex的注入是通过minxin的方法，在vue构建实例时通过钩子函数<code>beforeCreate</code>注入的。</p><h4 id="Getters的实现"><a href="#Getters的实现" class="headerlink" title="Getters的实现"></a>Getters的实现</h4><p><code>vuex</code>和<code>vue</code>一样是响应式的，<code>state</code>是通过放入<code>data</code>中实现，而<code>getters</code>是通过放入<code>computed</code>中做到响应式的。  </p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scss</title>
      <link href="2020/11/15/scss/"/>
      <url>2020/11/15/scss/</url>
      
        <content type="html"><![CDATA[<h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>sass根据语法分为两种格式Sass和Scss。<br>scss与css更类似，有大括号，文件后缀是.scss。<br>sass使用缩进来表示关系，文件后缀是.sass。  </p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>变量以$开头，用来存储重复使用的数据，包括宽度、高度和颜色等等。<br>如果变量需要嵌在字符串中，则需要写在<code>#&#123;&#125;</code>中。<br>但是如果变量是数字要避免<code>#&#123;$value&#125;px</code>这种写法，尽量使用<code>$value * 1px</code>。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$side</span>: left;</span><br><span class="line"><span class="selector-class">.rounded</span> &#123;</span><br><span class="line"><span class="attribute">border</span>-#&#123;<span class="variable">$side</span>&#125;-radius: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">###### 全局变量与局部变量</span><br><span class="line">定义在顶层的是全局变量，定义在块中的是局部变量，局部变量可以跟全局变量重名。  </span><br><span class="line">```SCSS</span><br><span class="line"><span class="variable">$global-variable</span>: global value;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line"><span class="variable">$local-variable</span>: local value;</span><br><span class="line">global: <span class="variable">$global-variable</span>;</span><br><span class="line">local: <span class="variable">$local-variable</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">如果需要在局部环境声明一个全局变量，使用!global标志。</span><br><span class="line">```SCSS</span><br><span class="line"><span class="variable">$variable</span>: first global value;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line"><span class="variable">$variable</span>: second global value !global;</span><br><span class="line">value: <span class="variable">$variable</span>;  <span class="comment">//second global value;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">value: <span class="variable">$variable</span>;  <span class="comment">// second global value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h5><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line"><span class="selector-class">.ul</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//css</span><br><span class="line">nav ul&#123;</span><br><span class="line">margin: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套的代码块中，可以引用父级元素。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ffb3ff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>不需要将所有sass写在同一个文件中，可以根据功能或者意义分割成模块。<br>然后使用<code>@use</code>引入模块。当前只有Dart Sass支持<code>@use</code>，其他使用<code>@import</code>。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_base.scss</span></span><br><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//style.scss</span></span><br><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;base&#x27;</span>;</span><br><span class="line"><span class="selector-class">.inverse</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: base.<span class="variable">$primary-color</span>;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h5><p>在考虑浏览器兼容性的时候，有很多属性需要重复写，这时候使用混入，用混入<br>的方式写兼容性语句，只需要考虑样式的值，不需要重复的书写。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> transfrom(<span class="variable">$property</span>) &#123;</span><br><span class="line">-webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&#123; <span class="keyword">@include</span> tansform(rorate(<span class="number">30deg</span>)); &#125;</span><br></pre></td></tr></table></figure><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>当一个基本样式不变的组件有多种样式，使用继承的方式可以减少重复代码。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%message-shared &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%message-heights &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.message</span>&#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sucess</span> &#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line"><span class="attribute">border</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line"><span class="keyword">@extend</span> %message-shared;</span><br><span class="line"><span class="attribute">border</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>sass支持一些标准的数学运算符，比如+、-、*、/和%。  </p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[role=&#x27;main&#x27;]</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">600px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span><span class="selector-attr">[role=&#x27;complementary&#x27;]</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span> / <span class="number">960px</span> * <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">##### 注释</span><br><span class="line">标准的注释<span class="comment">/* comment */</span>，会保留到编译后的文件。  </span><br><span class="line">单行注释<span class="comment">// comment，只保留在源文件中，编译后被省略。  </span></span><br><span class="line">在<span class="comment">/*后加上!，表示这是重要注释。即使是压缩模式编译，也会保留这行注释，通常  </span></span><br><span class="line"><span class="comment">可以用于声明版权信息。  </span></span><br><span class="line"><span class="comment">```SCSS</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    important comment</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h5><h6 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h6><p><code>@if</code>和<code>@else</code></p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> === <span class="number">2</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid; &#125;</span><br><span class="line"><span class="keyword">@else</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> dotted; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> to <span class="number">10</span> &#123;</span><br><span class="line"><span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="variable">$i</span> * <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环</span></span><br><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line"><span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//each</span></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">.#&#123;member&#125; &#123;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">&#x27;/image/#&#123;member&#125;.jpg&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> double(<span class="variable">$n</span>) &#123;</span><br><span class="line"><span class="keyword">@return</span> <span class="variable">$n</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sider</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><h6 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h6><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%)  <span class="comment">//#d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%)  <span class="comment">//#a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>)  <span class="comment">//#808080</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">//#33c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SCSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="2020/11/14/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2020/11/14/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>最近因为碰到取值问题打算好好看下Vue的生命周期，之前只是简单的了解了下Vue的生命周期。浅略的知道分为<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>、<code>beforeUpdate</code>、<code>updated</code>、<code>beforeDestroy</code>、<code>destroyed</code>，但是对于在这之间Vue的不同阶段到底做了什么不甚了解。</p><h5 id="vue的源码"><a href="#vue的源码" class="headerlink" title="vue的源码"></a>vue的源码</h5><p>分析生命周期，我们首先得从创建vue实例开始。<br>在<code>new Vue()</code>的时候，<code>vue/src/core/instance/index.js</code>中的<code>_init()</code>负责初始化各个功能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> instance Vue)</span>)</span>&#123;</span><br><span class="line">        warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_init</code>中的执行顺序为下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initLifeClircle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">initInjections(vm)  <span class="comment">//resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm)  <span class="comment">//resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而在<code>initState()</code>中执行顺序如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(opts.props) initProps(vm, opts.props)  <span class="comment">//初始化props</span></span><br><span class="line"><span class="keyword">if</span>(opts.methods) initMethods(vm, opts.methods)  <span class="comment">//初始化methods</span></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">opts.data</span>)</span> &#123;</span><br><span class="line">    initData(vm, opts.data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* as root data*/</span>);  <span class="comment">//初始化data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opts.computed) initComputed(vm, opts.computed);  <span class="comment">//初始化computed</span></span><br></pre></td></tr></table></figure><p>可以看出先执行<code>props</code>，然后是<code>methods</code>，紧接着是<code>data</code>最后是<code>computed</code>。并且这个阶段是在<code>beforeCreated</code>和<code>created</code>之间，<br>所以使用computed中的数据时需要慎重。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> lifeCircle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="2020/11/14/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>2020/11/14/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="重新搭建的原因"><a href="#重新搭建的原因" class="headerlink" title="重新搭建的原因"></a>重新搭建的原因</h4><p>因为以前的博客由于种种事由断更了很久，电脑也换了一个又一个。<br>原来的项目源文件已经丢失了，只剩下现在的编译之后的静态页面，<br>虽然是打算自己搭网站的，但是最近一直没空，先维护一下静态博客。</p><h4 id="使用的脚手架"><a href="#使用的脚手架" class="headerlink" title="使用的脚手架"></a>使用的脚手架</h4><p>依然是<a href="https://hexo.io/">hexo</a>，不过主题这次选择melody，<a href="https://molunerfinn.com/hexo-theme-melody-doc/">melody相关配置</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> melody </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/14/hello-world/"/>
      <url>2020/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
